<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>AfterShot Web Prototype</title>

  <!-- ffmpeg.wasm (no build tools; works on GitHub Pages) -->
  <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.12.10/dist/ffmpeg.min.js"></script>

  <style>
    :root{
      --bg: #0b0f14;
      --panel: rgba(15, 20, 28, 0.72);
      --panel2: rgba(15, 20, 28, 0.86);
      --text: #e7eef7;
      --muted: rgba(231, 238, 247, 0.68);
      --border: rgba(231, 238, 247, 0.16);
      --accent: #ffffff;
      --danger: #ff4d4d;
      --ok: #3ddc84;
      --shadow: 0 8px 28px rgba(0,0,0,0.45);
      --radius: 16px;
      --pad: 14px;
      --btnH: 56px;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { overflow: hidden; }

    /* Fullscreen video */
    #videoWrap { position: fixed; inset: 0; background: #000; }
    #preview { width: 100%; height: 100%; object-fit: cover; background: #000; }

    /* Top bar */
    .topbar {
      position: fixed;
      top: env(safe-area-inset-top);
      left: env(safe-area-inset-left);
      right: env(safe-area-inset-right);
      padding: 10px 12px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      pointer-events: none;
      z-index: 40;
    }
    .chipRow { display:flex; gap:8px; flex-wrap: wrap; align-items:center; pointer-events: auto; }
    .chip {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      color: var(--text);
      backdrop-filter: blur(8px);
      box-shadow: var(--shadow);
      display: inline-flex;
      gap: 8px;
      align-items: center;
    }
    .chip b { font-weight: 650; }
    .dot { width: 8px; height: 8px; border-radius: 99px; background: rgba(255,255,255,0.35); }
    .dot.ok { background: var(--ok); }
    .dot.bad { background: var(--danger); }

    /* Dropdown menu */
    .menu { position: relative; pointer-events:auto; }
    .menuBtn {
      height: 38px;
      padding: 0 12px;
      border-radius: 999px;
      background: var(--panel);
      border: 1px solid var(--border);
      color: var(--text);
      backdrop-filter: blur(8px);
      box-shadow: var(--shadow);
      font-size: 13px;
      display:flex;
      align-items:center;
      gap:8px;
    }
    .menuBtn:active { transform: translateY(1px); }

    /* MENU PANEL: fixed + high z-index so it never goes behind bottom buttons */
    .menuPanel {
      position: fixed;
      top: calc(env(safe-area-inset-top) + 56px);
      right: 12px;
      width: min(420px, calc(100vw - 24px));
      max-height: calc(100vh - (env(safe-area-inset-top) + 56px) - (env(safe-area-inset-bottom) + 120px));
      overflow: auto;
      background: var(--panel2);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      padding: 10px;
      display: none;
      z-index: 80;
    }
    .menuPanel.open { display: block; }

    /* 3-step menu tabs */
    .stepTabs{
      display:flex;
      gap:8px;
      margin: 2px 0 10px;
    }
    .stepTab{
      flex:1;
      height: 36px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      font-size: 13px;
      display:flex;
      align-items:center;
      justify-content:center;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      cursor: pointer;
    }
    .stepTab.active{
      background: rgba(255,255,255,0.14);
      border-color: rgba(255,255,255,0.25);
    }
    .stepPage{ display:none; }
    .stepPage.active{ display:block; }

    .sectionTitle {
      margin: 6px 0 8px;
      font-size: 12px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }
    .field { margin: 10px 0; }
    label { display:block; font-size: 12px; color: var(--muted); margin-bottom: 6px; }
    input[type="number"], input[type="range"]{ width: 100%; accent-color: var(--accent); }
    input[type="number"]{
      background: rgba(255,255,255,0.06);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px 10px;
      outline: none;
    }
    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .toggle { display:flex; align-items:center; gap:10px; margin-top: 8px; color: var(--muted); font-size: 12px; }
    .toggle input { transform: scale(1.15); }

    .downloads .item{
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
      padding: 10px;
      margin: 10px 0;
    }
    .downloads .title{
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 8px;
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .downloads .row{
      display:flex;
      gap:8px;
      flex-wrap: wrap;
      align-items:center;
    }
    .downloads a{
      display:inline-block;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      text-decoration: none;
      font-size: 13px;
    }
    .downloads .status{
      font-size: 12px;
      color: var(--muted);
      margin-top: 8px;
      line-height: 1.35;
    }
    .pill{
      display:inline-flex;
      gap:8px;
      align-items:center;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.06);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      color: var(--text);
    }

    /* Bottom overlay controls */
    .bottomBar {
      position: fixed;
      left: env(safe-area-inset-left);
      right: env(safe-area-inset-right);
      bottom: env(safe-area-inset-bottom);
      padding: 12px;
      pointer-events: none;
      z-index: 20;
    }
    .controls {
      pointer-events: auto;
      width: 100%;
      background: var(--panel2);
      border: 1px solid var(--border);
      border-radius: 18px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      display: grid;
      grid-template-columns: 1fr 1fr 1fr 1fr;
      gap: 10px;
      padding: 10px;
    }
    .btn {
      height: var(--btnH);
      border-radius: 16px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      font-size: 15px;
      font-weight: 650;
      display:flex;
      align-items:center;
      justify-content:center;
      gap: 10px;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      cursor: pointer;
    }
    .btn.primary { background: rgba(255,255,255,0.14); border-color: rgba(255,255,255,0.25); }
    .btn.danger { background: rgba(255,77,77,0.18); border-color: rgba(255,77,77,0.28); }
    .btn:active { transform: translateY(1px); }

    /* Helper text overlay */
    .hint {
      position: fixed;
      left: env(safe-area-inset-left);
      right: env(safe-area-inset-right);
      bottom: calc(env(safe-area-inset-bottom) + 92px);
      padding: 0 12px;
      display:flex;
      justify-content: center;
      pointer-events:none;
      z-index: 10;
    }
    .hint .chip { max-width: 92vw; }

    /* Landscape hint */
    .rotateOverlay{
      position: fixed;
      inset: 0;
      display: none;
      align-items:center;
      justify-content:center;
      background: rgba(0,0,0,0.65);
      z-index: 50;
      padding: 18px;
      text-align:center;
    }
    .rotateOverlay.show { display:flex; }
    .rotateOverlay .box{
      max-width: 560px;
      background: rgba(15,20,28,0.92);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 16px;
      box-shadow: var(--shadow);
    }
    .rotateOverlay h3{ margin: 0 0 6px; }
    .rotateOverlay p{ margin: 0; color: var(--muted); }

  </style>
</head>
<body>

  <div id="videoWrap">
    <video id="preview" playsinline muted></video>
  </div>

  <div class="topbar">
    <div class="chipRow">
      <div class="chip"><span class="dot" id="dotMode"></span><b id="mode">IDLE</b></div>
      <div class="chip">Buffer <span id="bufInfo" class="mono">0</span></div>
      <div class="chip">Δ <span id="delta" class="mono">–</span>°</div>
      <div class="chip">Wake <span id="wake" class="mono">OFF</span></div>
      <div class="chip">MP4 <span id="mp4Status" class="mono">idle</span></div>
    </div>

    <div class="menu">
      <button class="menuBtn" id="menuBtn">Menu ▾</button>

      <div class="menuPanel" id="menuPanel">
        <div class="stepTabs">
          <div class="stepTab active" id="tabVideo">Video</div>
          <div class="stepTab" id="tabDetect">Detection</div>
          <div class="stepTab" id="tabDownloads">Downloads</div>
        </div>

        <!-- PAGE 1 -->
        <div class="stepPage active" id="pageVideo">
          <div class="sectionTitle">Video settings</div>

          <div class="grid2">
            <div class="field">
              <label>Pre-roll X (seconds)</label>
              <input id="preSec" type="number" min="1" max="30" value="10"/>
            </div>
            <div class="field">
              <label>Post-roll Y (seconds)</label>
              <input id="postSec" type="number" min="1" max="30" value="5"/>
            </div>
          </div>

          <div class="field">
            <label>Chunk size (ms)</label>
            <input id="chunkMs" type="number" min="100" max="2000" step="50" value="250"/>
          </div>

          <div class="sectionTitle">Muzzle-down standby (calibrated)</div>

          <div class="grid2">
            <div class="field">
              <label>Down threshold Δ (degrees)</label>
              <input id="downDeg" type="number" min="10" max="85" value="50"/>
            </div>
            <div class="field">
              <label>Down duration (ms)</label>
              <input id="downMs" type="number" min="200" max="5000" step="100" value="1500"/>
            </div>
          </div>

          <div class="grid2">
            <div class="field">
              <label>Resume threshold Δ (degrees)</label>
              <input id="upDeg" type="number" min="0" max="80" value="35"/>
            </div>
            <div class="field">
              <label>Resume duration (ms)</label>
              <input id="upMs" type="number" min="100" max="5000" step="100" value="500"/>
            </div>
          </div>

          <div class="toggle">
            <input id="invertPitch" type="checkbox" />
            <span>Invert pitch (if Δ goes the wrong way)</span>
          </div>

          <div class="toggle">
            <input id="enableStandby" type="checkbox" checked />
            <span>Enable standby</span>
          </div>

          <div class="sectionTitle">Display</div>

          <div class="toggle">
            <input id="autoFullscreen" type="checkbox" checked />
            <span>Auto fullscreen on Start</span>
          </div>

          <div class="toggle">
            <input id="autoLandscape" type="checkbox" checked />
            <span>Try lock landscape (fullscreen only)</span>
          </div>

          <div class="sectionTitle">MP4 conversion</div>
          <div class="toggle">
            <input id="enableMp4" type="checkbox" checked />
            <span>Also convert every clip to MP4 (CPU heavy)</span>
          </div>
          <div style="color: var(--muted); font-size: 12px; line-height: 1.35; margin-top: 6px;">
            MP4 conversion runs locally in your browser using ffmpeg.wasm. On older phones it may be slow or fail.
          </div>
        </div>

        <!-- PAGE 2 -->
        <div class="stepPage" id="pageDetect">
          <div class="sectionTitle">Shot detection (audio)</div>

          <div class="field">
            <label>Peak threshold</label>
            <input id="thrPeak" type="range" min="0.05" max="1.0" step="0.01" value="0.35"/>
          </div>

          <div class="field">
            <label>Impulse score threshold (peak/rms)</label>
            <input id="thrScore" type="range" min="1" max="30" step="0.5" value="8"/>
          </div>

          <div class="grid2">
            <div class="field">
              <label>Cooldown (ms)</label>
              <input id="cooldownMs" type="number" min="100" max="5000" step="50" value="600"/>
            </div>
            <div class="field">
              <label>Min trigger gap (ms)</label>
              <input id="minGapMs" type="number" min="0" max="5000" step="50" value="250"/>
            </div>
          </div>

          <div style="color: var(--muted); font-size: 13px; line-height: 1.35; margin-top: 6px;">
            Tip: If you get false triggers, increase <b>Peak</b> and/or <b>Score</b>, and slightly increase <b>Cooldown</b>.
          </div>
        </div>

        <!-- PAGE 3 -->
        <div class="stepPage" id="pageDownloads">
          <div class="sectionTitle">Downloads</div>
          <div class="downloads" id="downloads"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="hint">
    <div class="chip" id="hintChip">Tip: Tap <b>Calibrate</b> in ready position. Then muzzle-down Δ≥50° for 1.5s → standby.</div>
  </div>

  <div class="bottomBar">
    <div class="controls">
      <div class="btn primary" id="btnStart">Start</div>
      <div class="btn danger" id="btnStop">Stop</div>
      <div class="btn" id="btnCal">Calibrate</div>
      <div class="btn" id="btnTest">Test Trigger</div>
    </div>
  </div>

  <div class="rotateOverlay" id="rotateOverlay">
    <div class="box">
      <h3>Rotate to landscape</h3>
      <p>This prototype is designed for landscape. If your browser supports it, Start will try to lock landscape in fullscreen.</p>
    </div>
  </div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  // UI
  const preview = $("preview");
  const modeEl = $("mode");
  const dotMode = $("dotMode");
  const bufInfoEl = $("bufInfo");
  const deltaEl = $("delta");
  const wakeEl = $("wake");
  const mp4StatusEl = $("mp4Status");
  const downloadsRoot = $("downloads");
  const rotateOverlay = $("rotateOverlay");

  const menuBtn = $("menuBtn");
  const menuPanel = $("menuPanel");

  // 3-step menu
  const tabVideo = $("tabVideo");
  const tabDetect = $("tabDetect");
  const tabDownloads = $("tabDownloads");
  const pageVideo = $("pageVideo");
  const pageDetect = $("pageDetect");
  const pageDownloads = $("pageDownloads");

  function setMenuStep(step) {
    tabVideo.classList.toggle("active", step === "video");
    tabDetect.classList.toggle("active", step === "detect");
    tabDownloads.classList.toggle("active", step === "downloads");

    pageVideo.classList.toggle("active", step === "video");
    pageDetect.classList.toggle("active", step === "detect");
    pageDownloads.classList.toggle("active", step === "downloads");
  }

  tabVideo.addEventListener("click", () => setMenuStep("video"));
  tabDetect.addEventListener("click", () => setMenuStep("detect"));
  tabDownloads.addEventListener("click", () => setMenuStep("downloads"));

  // Buttons
  const btnStart = $("btnStart");
  const btnStop  = $("btnStop");
  const btnCal   = $("btnCal");
  const btnTest  = $("btnTest");

  // Settings
  const preSecEl = $("preSec");
  const postSecEl = $("postSec");
  const chunkMsEl = $("chunkMs");

  const thrPeakEl = $("thrPeak");
  const thrScoreEl = $("thrScore");
  const cooldownMsEl = $("cooldownMs");
  const minGapMsEl = $("minGapMs");

  const downDegEl = $("downDeg");
  const downMsEl = $("downMs");
  const upDegEl = $("upDeg");
  const upMsEl = $("upMs");

  const invertPitchEl = $("invertPitch");
  const enableStandbyEl = $("enableStandby");

  const autoFullscreenEl = $("autoFullscreen");
  const autoLandscapeEl = $("autoLandscape");

  const enableMp4El = $("enableMp4");

  // State
  let stream = null;
  let recorder = null;

  // Ring buffer of chunks: {blob, durMs}
  let ring = [];
  let ringDurMs = 0;

  // Event capture
  let state = "IDLE"; // IDLE | ARMED | RECORD_EVENT | STANDBY
  let eventChunks = null;
  let postTimer = null;

  // Audio detection
  let audioCtx = null;
  let analyser = null;
  let audioData = null;
  let lastTriggerTs = 0;
  let lastPeakTs = 0;

  // Wake lock
  let wakeLock = null;

  // Orientation calibration
  let lastBetaRaw = null;
  let refBeta = 0;
  let hasCal = false;

  let downStart = null;
  let upStart = null;

  const nowPerf = () => performance.now();

  // ---------- helpers ----------
  function setMode(m) {
    state = m;
    modeEl.textContent = m;
    dotMode.className = "dot" + (m === "ARMED" ? " ok" : (m === "RECORD_EVENT" ? " ok" : (m === "STANDBY" ? "" : "")));
  }

  function updateBufInfo() {
    const preMs = Number(preSecEl.value) * 1000;
    bufInfoEl.textContent = `${ring.length} / ~${(ringDurMs/1000).toFixed(1)}s (target ${(preMs/1000).toFixed(1)}s)`;
  }

  function bestMimeType() {
    const candidates = [
      "video/webm;codecs=vp9,opus",
      "video/webm;codecs=vp8,opus",
      "video/webm"
    ];
    for (const t of candidates) if (MediaRecorder.isTypeSupported(t)) return t;
    return "";
  }

  // ---------- menu ----------
  function toggleMenu(force) {
    const open = (force !== undefined) ? force : !menuPanel.classList.contains("open");
    menuPanel.classList.toggle("open", open);
  }
  menuBtn.addEventListener("click", (e) => { e.stopPropagation(); toggleMenu(); });
  document.addEventListener("click", () => toggleMenu(false));
  menuPanel.addEventListener("click", (e) => e.stopPropagation());

  // ---------- wake lock ----------
  async function requestWakeLock() {
    try {
      if (!("wakeLock" in navigator)) { wakeEl.textContent = "N/A"; return; }
      wakeLock = await navigator.wakeLock.request("screen");
      wakeEl.textContent = "ON";
      wakeLock.addEventListener("release", () => { wakeEl.textContent = "OFF"; });
    } catch (e) {
      wakeEl.textContent = "FAIL";
      console.warn("WakeLock failed:", e);
    }
  }

  async function releaseWakeLock() {
    try { if (wakeLock) await wakeLock.release(); } catch {}
    wakeLock = null;
    wakeEl.textContent = ("wakeLock" in navigator) ? "OFF" : "N/A";
  }

  document.addEventListener("visibilitychange", async () => {
    if (document.visibilityState === "visible" && state !== "IDLE") {
      await requestWakeLock();
    }
  });

  // ---------- fullscreen + orientation lock ----------
  async function goFullscreen() {
    const el = document.documentElement;
    if (!document.fullscreenElement && el.requestFullscreen) {
      await el.requestFullscreen({ navigationUI: "hide" }).catch(()=>{});
    }
  }

  async function lockLandscape() {
    try {
      if (screen.orientation && screen.orientation.lock) {
        await screen.orientation.lock("landscape");
      }
    } catch (e) {
      console.warn("Orientation lock failed:", e);
    }
  }

  function updateRotateOverlay() {
    const isLandscape = window.matchMedia("(orientation: landscape)").matches;
    rotateOverlay.classList.toggle("show", !isLandscape && state === "IDLE");
  }
  window.addEventListener("resize", updateRotateOverlay);
  window.addEventListener("orientationchange", updateRotateOverlay);

  // ---------- ring buffer ----------
  function pushChunk(blob, durMs) {
    ring.push({ blob, durMs });
    ringDurMs += durMs;

    const keepMs = Number(preSecEl.value) * 1000;
    while (ringDurMs > keepMs && ring.length > 1) {
      const old = ring.shift();
      ringDurMs -= old.durMs;
    }
    updateBufInfo();
  }

  function snapshotPreRoll() { return ring.map(x => x.blob); }

  // ---------- audio detection ----------
  function setupAudioDetection(audioOnlyStream) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const src = audioCtx.createMediaStreamSource(audioOnlyStream);

    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;
    analyser.smoothingTimeConstant = 0.2;

    src.connect(analyser);
    audioData = new Float32Array(analyser.fftSize);

    const loop = () => {
      if (!analyser) return;

      analyser.getFloatTimeDomainData(audioData);

      let peak = 0, sumSq = 0;
      for (let i=0;i<audioData.length;i++){
        const v = audioData[i];
        const a = Math.abs(v);
        if (a > peak) peak = a;
        sumSq += v*v;
      }
      const rms = Math.sqrt(sumSq / audioData.length);
      const score = peak / (rms + 1e-6);

      if (state === "ARMED") {
        const t = nowPerf();
        const thrPeak = Number(thrPeakEl.value);
        const thrScore = Number(thrScoreEl.value);
        const cooldown = Number(cooldownMsEl.value);
        const minGap = Number(minGapMsEl.value);

        const coolOk = (t - lastTriggerTs) > cooldown;
        const gapOk = (t - lastPeakTs) > minGap;

        if (peak > thrPeak * 0.6) lastPeakTs = t;

        if (coolOk && gapOk && peak >= thrPeak && score >= thrScore) {
          triggerEvent("audio");
        }
      }

      requestAnimationFrame(loop);
    };

    loop();
  }

  // ---------- downloads UI helpers ----------
  function createDownloadItem(baseName) {
    const el = document.createElement("div");
    el.className = "item";

    const title = document.createElement("div");
    title.className = "title";
    title.textContent = baseName;

    const row = document.createElement("div");
    row.className = "row";

    const status = document.createElement("div");
    status.className = "status";
    status.textContent = "Saved WebM. MP4 conversion pending…";

    el.appendChild(title);
    el.appendChild(row);
    el.appendChild(status);
    downloadsRoot.prepend(el);

    return { el, row, status };
  }

  function addLink(row, blob, filename, label) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    a.textContent = label;
    row.appendChild(a);
    return a;
  }

  // ---------- MP4 conversion with ffmpeg.wasm ----------
  let ffmpegInstance = null;
  let ffmpegLoading = false;

  async function ensureFfmpegLoaded() {
    if (ffmpegInstance) return ffmpegInstance;
    if (ffmpegLoading) {
      // wait until it finishes
      while (ffmpegLoading) await new Promise(r => setTimeout(r, 150));
      if (ffmpegInstance) return ffmpegInstance;
    }

    ffmpegLoading = true;
    mp4StatusEl.textContent = "loading";

    try {
      const { createFFmpeg, fetchFile } = FFmpeg;
      const ffmpeg = createFFmpeg({
        log: false,
        // corePath is important on static hosting
        corePath: "https://unpkg.com/@ffmpeg/core@0.12.6/dist/ffmpeg-core.js"
      });

      ffmpeg.setProgress(({ ratio }) => {
        // ratio 0..1
        const pct = Math.min(99, Math.max(0, Math.round((ratio || 0) * 100)));
        mp4StatusEl.textContent = `mp4 ${pct}%`;
      });

      await ffmpeg.load();
      ffmpegInstance = { ffmpeg, fetchFile };
      mp4StatusEl.textContent = "ready";
      return ffmpegInstance;
    } catch (e) {
      console.warn("FFmpeg load failed:", e);
      mp4StatusEl.textContent = "fail";
      throw e;
    } finally {
      ffmpegLoading = false;
    }
  }

  async function webmToMp4(webmBlob) {
    const { ffmpeg, fetchFile } = await ensureFfmpegLoaded();

    // Use unique names to avoid collisions
    const inName = `in_${Date.now()}_${Math.random().toString(16).slice(2)}.webm`;
    const outName = `out_${Date.now()}_${Math.random().toString(16).slice(2)}.mp4`;

    ffmpeg.FS("writeFile", inName, await fetchFile(webmBlob));

    // Try H.264 + AAC first (best compatibility). If not available, fallback to MPEG-4 Part 2.
    const attempts = [
      ["-i", inName, "-c:v", "libx264", "-preset", "veryfast", "-crf", "28", "-c:a", "aac", "-b:a", "128k", outName],
      ["-i", inName, "-c:v", "mpeg4", "-q:v", "6", "-c:a", "aac", "-b:a", "128k", outName],
      ["-i", inName, "-c:v", "mpeg4", "-q:v", "6", "-c:a", "mp3", "-b:a", "128k", outName]
    ];

    let lastErr = null;
    for (const args of attempts) {
      try {
        mp4StatusEl.textContent = "mp4 0%";
        await ffmpeg.run(...args);
        const data = ffmpeg.FS("readFile", outName);
        // cleanup
        try { ffmpeg.FS("unlink", inName); } catch {}
        try { ffmpeg.FS("unlink", outName); } catch {}
        mp4StatusEl.textContent = "done";
        return new Blob([data.buffer], { type: "video/mp4" });
      } catch (e) {
        lastErr = e;
        // cleanup between attempts
        try { ffmpeg.FS("unlink", outName); } catch {}
      }
    }

    mp4StatusEl.textContent = "fail";
    throw lastErr || new Error("MP4 conversion failed");
  }

  // ---------- event capture ----------
  function triggerEvent(reason) {
    lastTriggerTs = nowPerf();
    if (state !== "ARMED") return;

    setMode("RECORD_EVENT");
    eventChunks = [...snapshotPreRoll()];

    clearTimeout(postTimer);
    postTimer = setTimeout(() => finalizeEvent(reason), Number(postSecEl.value) * 1000);
  }

  async function finalizeEvent(reason) {
    if (!eventChunks) return;

    const webmBlob = new Blob(eventChunks, { type: recorder?.mimeType || "video/webm" });
    const ts = new Date().toISOString().replace(/[:.]/g, "-");
    const base = `aftershot_${ts}_${reason}_pre${preSecEl.value}s_post${postSecEl.value}s`;
    const webmName = `${base}.webm`;
    const mp4Name  = `${base}.mp4`;

    // Create downloads UI entry
    const item = createDownloadItem(base);
    addLink(item.row, webmBlob, webmName, "Download WebM");

    // Jump to Downloads and open menu
    setMenuStep("downloads");
    toggleMenu(true);

    // Start MP4 conversion (optional toggle)
    if (enableMp4El.checked) {
      item.status.textContent = "Converting to MP4… (this can take a while)";
      try {
        const mp4Blob = await webmToMp4(webmBlob);
        addLink(item.row, mp4Blob, mp4Name, "Download MP4");
        item.status.textContent = "MP4 ready.";
      } catch (e) {
        console.warn("MP4 conversion failed:", e);
        item.status.textContent = "MP4 conversion failed on this device/browser. WebM is still available.";
      }
    } else {
      item.status.textContent = "MP4 conversion disabled. WebM ready.";
    }

    eventChunks = null;

    if (enableStandbyEl.checked && isMuzzleDown()) goStandby();
    else setMode("ARMED");
  }

  // ---------- recorder ----------
  function startRecorder() {
    const chunkMs = Number(chunkMsEl.value);
    const mime = bestMimeType();
    recorder = new MediaRecorder(stream, mime ? { mimeType: mime } : undefined);

    let lastChunkT = nowPerf();

    recorder.ondataavailable = (ev) => {
      if (!ev.data || ev.data.size === 0) return;
      const t = nowPerf();
      const durMs = Math.max(1, Math.round(t - lastChunkT));
      lastChunkT = t;

      pushChunk(ev.data, durMs);

      if (state === "RECORD_EVENT" && eventChunks) eventChunks.push(ev.data);
    };

    recorder.onstop = () => { recorder = null; };
    recorder.start(chunkMs);
  }

  // ---------- orientation (calibrated) ----------
  function effectiveBeta(betaRaw) {
    if (betaRaw == null || Number.isNaN(betaRaw)) return null;
    return invertPitchEl.checked ? -betaRaw : betaRaw;
  }

  function deltaBeta() {
    const b = effectiveBeta(lastBetaRaw);
    if (b == null) return null;
    const ref = hasCal ? refBeta : 0;
    return b - ref;
  }

  function isMuzzleDown() {
    const d = deltaBeta();
    if (d == null) return false;
    return d >= Number(downDegEl.value);
  }

  function isMuzzleUp() {
    const d = deltaBeta();
    if (d == null) return false;
    return d <= Number(upDegEl.value);
  }

  function onOrientation(ev) {
    lastBetaRaw = ev.beta;
    const d = deltaBeta();
    deltaEl.textContent = (d == null) ? "–" : d.toFixed(1);

    if (!enableStandbyEl.checked) { downStart = null; upStart = null; return; }

    const t = nowPerf();

    if (state === "ARMED") {
      if (isMuzzleDown()) {
        if (downStart == null) downStart = t;
        if ((t - downStart) >= Number(downMsEl.value)) {
          goStandby();
          downStart = null;
          upStart = null;
        }
      } else {
        downStart = null;
      }
    } else if (state === "STANDBY") {
      if (isMuzzleUp()) {
        if (upStart == null) upStart = t;
        if ((t - upStart) >= Number(upMsEl.value)) {
          upStart = null;
          resumeFromStandby().catch(err => alert(err.message));
        }
      } else {
        upStart = null;
      }
    } else if (state === "RECORD_EVENT") {
      downStart = null;
      upStart = null;
    }
  }

  async function requestOrientationPermissionIfNeeded() {
    try {
      if (typeof DeviceOrientationEvent !== "undefined" &&
          typeof DeviceOrientationEvent.requestPermission === "function") {
        const res = await DeviceOrientationEvent.requestPermission();
        if (res !== "granted") console.warn("DeviceOrientation permission not granted.");
      }
    } catch (e) {
      console.warn("Orientation permission request failed:", e);
    }
  }

  window.addEventListener("deviceorientation", onOrientation, { passive: true });

  // ---------- media lifecycle ----------
  async function startArmed() {
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "environment" },
      audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }
    });

    preview.srcObject = stream;
    await preview.play();

    const audioOnly = new MediaStream(stream.getAudioTracks());
    setupAudioDetection(audioOnly);

    ring = [];
    ringDurMs = 0;
    updateBufInfo();

    startRecorder();
    setMode("ARMED");
  }

  function stopMediaPipelines() {
    clearTimeout(postTimer); postTimer = null;

    if (recorder && recorder.state !== "inactive") recorder.stop();
    recorder = null;

    if (audioCtx) { try { audioCtx.close(); } catch {} }
    audioCtx = null; analyser = null; audioData = null;

    if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
    preview.srcObject = null;

    ring = [];
    ringDurMs = 0;
    updateBufInfo();

    eventChunks = null;
  }

  function goStandby() {
    if (state === "RECORD_EVENT") return;
    stopMediaPipelines();
    setMode("STANDBY");
  }

  async function resumeFromStandby() {
    if (state !== "STANDBY") return;
    await startArmed();
  }

  // ---------- menu ----------
  function toggleMenu(force) {
    const open = (force !== undefined) ? force : !menuPanel.classList.contains("open");
    menuPanel.classList.toggle("open", open);
  }

  // ---------- buttons ----------
  btnStart.addEventListener("click", async () => {
    await requestOrientationPermissionIfNeeded();

    if (autoFullscreenEl.checked) await goFullscreen();
    if (autoLandscapeEl.checked) await lockLandscape();

    await requestWakeLock();
    await startArmed();

    toggleMenu(false);
    setMenuStep("video");
  });

  btnStop.addEventListener("click", async () => {
    stopMediaPipelines();
    setMode("IDLE");
    await releaseWakeLock();
    toggleMenu(false);
    updateRotateOverlay();
  });

  btnCal.addEventListener("click", () => {
    const b = effectiveBeta(lastBetaRaw);
    if (b == null) { alert("No orientation data yet. Move the phone a bit (and allow motion/orientation if asked)."); return; }
    refBeta = b;
    hasCal = true;
    const d = deltaBeta();
    deltaEl.textContent = (d == null) ? "–" : d.toFixed(1);
    toggleMenu(false);
  });

  btnTest.addEventListener("click", () => {
    if (state === "ARMED") triggerEvent("manual");
  });

  // ---------- init ----------
  wakeEl.textContent = ("wakeLock" in navigator) ? "OFF" : "N/A";
  mp4StatusEl.textContent = "idle";
  setMode("IDLE");
  updateBufInfo();
  updateRotateOverlay();

  // close menu when tapping outside
  menuBtn.addEventListener("click", (e) => { e.stopPropagation(); toggleMenu(); });
  document.addEventListener("click", () => toggleMenu(false));
  menuPanel.addEventListener("click", (e) => e.stopPropagation());

})();
</script>
</body>
</html>
